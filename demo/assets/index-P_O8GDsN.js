var me=Object.defineProperty,Ee=Object.defineProperties;var we=Object.getOwnPropertyDescriptors;var $=Object.getOwnPropertySymbols;var Q=Object.prototype.hasOwnProperty,j=Object.prototype.propertyIsEnumerable;var k=e=>{throw TypeError(e)};var L=(e,t,r)=>t in e?me(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r,m=(e,t)=>{for(var r in t||(t={}))Q.call(t,r)&&L(e,r,t[r]);if($)for(var r of $(t))j.call(t,r)&&L(e,r,t[r]);return e},U=(e,t)=>Ee(e,we(t));var ee=(e,t)=>{var r={};for(var n in e)Q.call(e,n)&&t.indexOf(n)<0&&(r[n]=e[n]);if(e!=null&&$)for(var n of $(e))t.indexOf(n)<0&&j.call(e,n)&&(r[n]=e[n]);return r};var h=(e,t,r)=>L(e,typeof t!="symbol"?t+"":t,r),te=(e,t,r)=>t.has(e)||k("Cannot "+r);var d=(e,t,r)=>(te(e,t,"read from private field"),r?r.call(e):t.get(e)),W=(e,t,r)=>t.has(e)?k("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(e):t.set(e,r),T=(e,t,r,n)=>(te(e,t,"write to private field"),n?n.call(e,r):t.set(e,r),r);var u=(e,t,r)=>new Promise((n,a)=>{var o=c=>{try{i(r.next(c))}catch(y){a(y)}},s=c=>{try{i(r.throw(c))}catch(y){a(y)}},i=c=>c.done?n(c.value):Promise.resolve(c.value).then(o,s);i((r=r.apply(e,t)).next())});const S=new TextEncoder,v=new TextDecoder;function ne(...e){const t=e.reduce((a,{length:o})=>a+o,0),r=new Uint8Array(t);let n=0;for(const a of e)r.set(a,n),n+=a.length;return r}function be(e){if(Uint8Array.prototype.toBase64)return e.toBase64();const t=32768,r=[];for(let n=0;n<e.length;n+=t)r.push(String.fromCharCode.apply(null,e.subarray(n,n+t)));return btoa(r.join(""))}function F(e){if(Uint8Array.fromBase64)return Uint8Array.fromBase64(e);const t=atob(e),r=new Uint8Array(t.length);for(let n=0;n<t.length;n++)r[n]=t.charCodeAt(n);return r}function N(e){if(Uint8Array.fromBase64)return Uint8Array.fromBase64(typeof e=="string"?e:v.decode(e),{alphabet:"base64url"});let t=e;t instanceof Uint8Array&&(t=v.decode(t)),t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return F(t)}catch(r){throw new TypeError("The input to be decoded is not correctly encoded.")}}function x(e){let t=e;return typeof t=="string"&&(t=S.encode(t)),Uint8Array.prototype.toBase64?t.toBase64({alphabet:"base64url",omitPadding:!0}):be(t).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}class R extends Error{constructor(r,n){var a;super(r,n);h(this,"code","ERR_JOSE_GENERIC");this.name=this.constructor.name,(a=Error.captureStackTrace)==null||a.call(Error,this,this.constructor)}}h(R,"code","ERR_JOSE_GENERIC");class ae extends R{constructor(){super(...arguments);h(this,"code","ERR_JOSE_ALG_NOT_ALLOWED")}}h(ae,"code","ERR_JOSE_ALG_NOT_ALLOWED");class w extends R{constructor(){super(...arguments);h(this,"code","ERR_JOSE_NOT_SUPPORTED")}}h(w,"code","ERR_JOSE_NOT_SUPPORTED");class f extends R{constructor(){super(...arguments);h(this,"code","ERR_JWS_INVALID")}}h(f,"code","ERR_JWS_INVALID");class oe extends R{constructor(){super(...arguments);h(this,"code","ERR_JWK_INVALID")}}h(oe,"code","ERR_JWK_INVALID");class se extends R{constructor(r="signature verification failed",n){super(r,n);h(this,"code","ERR_JWS_SIGNATURE_VERIFICATION_FAILED")}}h(se,"code","ERR_JWS_SIGNATURE_VERIFICATION_FAILED");function E(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function H(e,t){return e.name===t}function M(e){return parseInt(e.name.slice(4),10)}function Ae(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}function Ke(e,t){if(t&&!e.usages.includes(t))throw new TypeError(`CryptoKey does not support this operation, its usages must include ${t}.`)}function ge(e,t,r){switch(t){case"HS256":case"HS384":case"HS512":{if(!H(e.algorithm,"HMAC"))throw E("HMAC");const n=parseInt(t.slice(2),10);if(M(e.algorithm.hash)!==n)throw E(`SHA-${n}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!H(e.algorithm,"RSASSA-PKCS1-v1_5"))throw E("RSASSA-PKCS1-v1_5");const n=parseInt(t.slice(2),10);if(M(e.algorithm.hash)!==n)throw E(`SHA-${n}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!H(e.algorithm,"RSA-PSS"))throw E("RSA-PSS");const n=parseInt(t.slice(2),10);if(M(e.algorithm.hash)!==n)throw E(`SHA-${n}`,"algorithm.hash");break}case"Ed25519":case"EdDSA":{if(!H(e.algorithm,"Ed25519"))throw E("Ed25519");break}case"ES256":case"ES384":case"ES512":{if(!H(e.algorithm,"ECDSA"))throw E("ECDSA");const n=Ae(t);if(e.algorithm.namedCurve!==n)throw E(n,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}Ke(e,r)}function ie(e,t,...r){var n;if(r=r.filter(Boolean),r.length>2){const a=r.pop();e+=`one of type ${r.join(", ")}, or ${a}.`}else r.length===2?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;return t==null?e+=` Received ${t}`:typeof t=="function"&&t.name?e+=` Received function ${t.name}`:typeof t=="object"&&t!=null&&(n=t.constructor)!=null&&n.name&&(e+=` Received an instance of ${t.constructor.name}`),e}const Y=(e,...t)=>ie("Key must be ",e,...t);function ce(e,t,...r){return ie(`Key for the ${e} algorithm must be `,t,...r)}function z(e){return(e==null?void 0:e[Symbol.toStringTag])==="CryptoKey"}function q(e){return(e==null?void 0:e[Symbol.toStringTag])==="KeyObject"}const X=e=>z(e)||q(e),fe=(...e)=>{const t=e.filter(Boolean);if(t.length===0||t.length===1)return!0;let r;for(const n of t){const a=Object.keys(n);if(!r||r.size===0){r=new Set(a);continue}for(const o of a){if(r.has(o))return!1;r.add(o)}}return!0};function Pe(e){return typeof e=="object"&&e!==null}const G=e=>{if(!Pe(e)||Object.prototype.toString.call(e)!=="[object Object]")return!1;if(Object.getPrototypeOf(e)===null)return!0;let t=e;for(;Object.getPrototypeOf(t)!==null;)t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t},Ce=(e,t)=>u(void 0,null,function*(){const r=`SHA-${e.slice(-3)}`;return new Uint8Array(yield crypto.subtle.digest(r,t))}),de=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if(typeof r!="number"||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}},ve=e=>{const t=Object.entries({"P-256":[6,8,42,134,72,206,61,3,1,7],"P-384":[6,5,43,129,4,0,34],"P-521":[6,5,43,129,4,0,35]}),r=Math.max(...t.map(([,n])=>n.length));for(let n=0;n<=e.byteLength-r;n++)for(const[a,o]of t)if(n<=e.byteLength-o.length&&e.subarray(n,n+o.length).every((s,i)=>s===o[i]))return a},ue=(e,t,r,n)=>u(void 0,null,function*(){var y;let a,o;const s=e==="spki",i=()=>s?["verify"]:["sign"],c=()=>s?["encrypt","wrapKey"]:["decrypt","unwrapKey"];switch(r){case"PS256":case"PS384":case"PS512":a={name:"RSA-PSS",hash:`SHA-${r.slice(-3)}`},o=i();break;case"RS256":case"RS384":case"RS512":a={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${r.slice(-3)}`},o=i();break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":a={name:"RSA-OAEP",hash:`SHA-${parseInt(r.slice(-3),10)||1}`},o=c();break;case"ES256":case"ES384":case"ES512":{a={name:"ECDSA",namedCurve:{ES256:"P-256",ES384:"P-384",ES512:"P-521"}[r]},o=i();break}case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{const A=ve(t);a=A?{name:"ECDH",namedCurve:A}:{name:"X25519"},o=s?[]:["deriveBits"];break}case"Ed25519":case"EdDSA":a={name:"Ed25519"},o=i();break;default:throw new w('Invalid or unsupported "alg" (Algorithm) value')}return crypto.subtle.importKey(e,t,a,(y=n==null?void 0:n.extractable)!=null?y:!!s,o)}),Re=(e,t,r)=>{const n=F(e.replace(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g,""));return ue("pkcs8",n,t,r)},We=(e,t,r)=>{const n=F(e.replace(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g,""));return ue("spki",n,t,r)};function Te(e){let t,r;switch(e.kty){case"RSA":{switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`},r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`},r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new w('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"EC":{switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"},r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"},r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new w('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}case"OKP":{switch(e.alg){case"Ed25519":case"EdDSA":t={name:"Ed25519"},r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv},r=e.d?["deriveBits"]:[];break;default:throw new w('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break}default:throw new w('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}const He=e=>u(void 0,null,function*(){var a,o;if(!e.alg)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');const{algorithm:t,keyUsages:r}=Te(e),n=m({},e);return delete n.alg,delete n.use,crypto.subtle.importKey("jwk",n,t,(a=e.ext)!=null?a:!e.d,(o=e.key_ops)!=null?o:r)});function Ye(e,t,r){return u(this,null,function*(){if(typeof e!="string"||e.indexOf("-----BEGIN PUBLIC KEY-----")!==0)throw new TypeError('"spki" must be SPKI formatted string');return We(e,t,r)})}function ze(e,t,r){return u(this,null,function*(){if(typeof e!="string"||e.indexOf("-----BEGIN PRIVATE KEY-----")!==0)throw new TypeError('"pkcs8" must be PKCS#8 formatted string');return Re(e,t,r)})}const he=(e,t,r,n,a)=>{if(a.crit!==void 0&&(n==null?void 0:n.crit)===void 0)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||n.crit===void 0)return new Set;if(!Array.isArray(n.crit)||n.crit.length===0||n.crit.some(s=>typeof s!="string"||s.length===0))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let o;r!==void 0?o=new Map([...Object.entries(r),...t.entries()]):o=t;for(const s of n.crit){if(!o.has(s))throw new w(`Extension Header Parameter "${s}" is not recognized`);if(a[s]===void 0)throw new e(`Extension Header Parameter "${s}" is missing`);if(o.get(s)&&n[s]===void 0)throw new e(`Extension Header Parameter "${s}" MUST be integrity protected`)}return new Set(n.crit)},xe=(e,t)=>{if(t!==void 0&&(!Array.isArray(t)||t.some(r=>typeof r!="string")))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};function B(e){return G(e)&&typeof e.kty=="string"}function Oe(e){return e.kty!=="oct"&&typeof e.d=="string"}function Je(e){return e.kty!=="oct"&&typeof e.d=="undefined"}function De(e){return e.kty==="oct"&&typeof e.k=="string"}let P;const re=(e,t,r,n=!1)=>u(void 0,null,function*(){P||(P=new WeakMap);let a=P.get(e);if(a!=null&&a[r])return a[r];const o=yield He(U(m({},t),{alg:r}));return n&&Object.freeze(e),a?a[r]=o:P.set(e,{[r]:o}),o}),Ie=(e,t)=>{var s;P||(P=new WeakMap);let r=P.get(e);if(r!=null&&r[t])return r[t];const n=e.type==="public",a=!!n;let o;if(e.asymmetricKeyType==="x25519"){switch(t){case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":break;default:throw new TypeError("given KeyObject instance cannot be used for this algorithm")}o=e.toCryptoKey(e.asymmetricKeyType,a,n?[]:["deriveBits"])}if(e.asymmetricKeyType==="ed25519"){if(t!=="EdDSA"&&t!=="Ed25519")throw new TypeError("given KeyObject instance cannot be used for this algorithm");o=e.toCryptoKey(e.asymmetricKeyType,a,[n?"verify":"sign"])}if(e.asymmetricKeyType==="rsa"){let i;switch(t){case"RSA-OAEP":i="SHA-1";break;case"RS256":case"PS256":case"RSA-OAEP-256":i="SHA-256";break;case"RS384":case"PS384":case"RSA-OAEP-384":i="SHA-384";break;case"RS512":case"PS512":case"RSA-OAEP-512":i="SHA-512";break;default:throw new TypeError("given KeyObject instance cannot be used for this algorithm")}if(t.startsWith("RSA-OAEP"))return e.toCryptoKey({name:"RSA-OAEP",hash:i},a,n?["encrypt"]:["decrypt"]);o=e.toCryptoKey({name:t.startsWith("PS")?"RSA-PSS":"RSASSA-PKCS1-v1_5",hash:i},a,[n?"verify":"sign"])}if(e.asymmetricKeyType==="ec"){const c=new Map([["prime256v1","P-256"],["secp384r1","P-384"],["secp521r1","P-521"]]).get((s=e.asymmetricKeyDetails)==null?void 0:s.namedCurve);if(!c)throw new TypeError("given KeyObject instance cannot be used for this algorithm");t==="ES256"&&c==="P-256"&&(o=e.toCryptoKey({name:"ECDSA",namedCurve:c},a,[n?"verify":"sign"])),t==="ES384"&&c==="P-384"&&(o=e.toCryptoKey({name:"ECDSA",namedCurve:c},a,[n?"verify":"sign"])),t==="ES512"&&c==="P-521"&&(o=e.toCryptoKey({name:"ECDSA",namedCurve:c},a,[n?"verify":"sign"])),t.startsWith("ECDH-ES")&&(o=e.toCryptoKey({name:"ECDH",namedCurve:c},a,n?[]:["deriveBits"]))}if(!o)throw new TypeError("given KeyObject instance cannot be used for this algorithm");return r?r[t]=o:P.set(e,{[t]:o}),o},pe=(e,t)=>u(void 0,null,function*(){if(e instanceof Uint8Array||z(e))return e;if(q(e)){if(e.type==="secret")return e.export();if("toCryptoKey"in e&&typeof e.toCryptoKey=="function")try{return Ie(e,t)}catch(n){if(n instanceof TypeError)throw n}let r=e.export({format:"jwk"});return re(e,r,t)}if(B(e))return e.k?N(e.k):re(e,e,t,!0);throw new Error("unreachable")}),g=e=>e==null?void 0:e[Symbol.toStringTag],V=(e,t,r)=>{var n,a;if(t.use!==void 0){let o;switch(r){case"sign":case"verify":o="sig";break;case"encrypt":case"decrypt":o="enc";break}if(t.use!==o)throw new TypeError(`Invalid key for this operation, its "use" must be "${o}" when present`)}if(t.alg!==void 0&&t.alg!==e)throw new TypeError(`Invalid key for this operation, its "alg" must be "${e}" when present`);if(Array.isArray(t.key_ops)){let o;switch(!0){case(r==="sign"||r==="verify"):case e==="dir":case e.includes("CBC-HS"):o=r;break;case e.startsWith("PBES2"):o="deriveBits";break;case/^A\d{3}(?:GCM)?(?:KW)?$/.test(e):!e.includes("GCM")&&e.endsWith("KW")?o=r==="encrypt"?"wrapKey":"unwrapKey":o=r;break;case(r==="encrypt"&&e.startsWith("RSA")):o="wrapKey";break;case r==="decrypt":o=e.startsWith("RSA")?"unwrapKey":"deriveBits";break}if(o&&((a=(n=t.key_ops)==null?void 0:n.includes)==null?void 0:a.call(n,o))===!1)throw new TypeError(`Invalid key for this operation, its "key_ops" must include "${o}" when present`)}return!0},_e=(e,t,r)=>{if(!(t instanceof Uint8Array)){if(B(t)){if(De(t)&&V(e,t,r))return;throw new TypeError('JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present')}if(!X(t))throw new TypeError(ce(e,t,"CryptoKey","KeyObject","JSON Web Key","Uint8Array"));if(t.type!=="secret")throw new TypeError(`${g(t)} instances for symmetric algorithms must be of type "secret"`)}},$e=(e,t,r)=>{if(B(t))switch(r){case"decrypt":case"sign":if(Oe(t)&&V(e,t,r))return;throw new TypeError("JSON Web Key for this operation be a private JWK");case"encrypt":case"verify":if(Je(t)&&V(e,t,r))return;throw new TypeError("JSON Web Key for this operation be a public JWK")}if(!X(t))throw new TypeError(ce(e,t,"CryptoKey","KeyObject","JSON Web Key"));if(t.type==="secret")throw new TypeError(`${g(t)} instances for asymmetric algorithms must not be of type "secret"`);if(t.type==="public")switch(r){case"sign":throw new TypeError(`${g(t)} instances for asymmetric algorithm signing must be of type "private"`);case"decrypt":throw new TypeError(`${g(t)} instances for asymmetric algorithm decryption must be of type "private"`)}if(t.type==="private")switch(r){case"verify":throw new TypeError(`${g(t)} instances for asymmetric algorithm verifying must be of type "public"`);case"encrypt":throw new TypeError(`${g(t)} instances for asymmetric algorithm encryption must be of type "public"`)}},ye=(e,t,r)=>{e.startsWith("HS")||e==="dir"||e.startsWith("PBES2")||/^A(?:128|192|256)(?:GCM)?(?:KW)?$/.test(e)||/^A(?:128|192|256)CBC-HS(?:256|384|512)$/.test(e)?_e(e,t,r):$e(e,t,r)};function Ue(e){return u(this,null,function*(){if(q(e))if(e.type==="secret")e=e.export();else return e.export({format:"jwk"});if(e instanceof Uint8Array)return{kty:"oct",k:x(e)};if(!z(e))throw new TypeError(Y(e,"CryptoKey","KeyObject","Uint8Array"));if(!e.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");const s=yield crypto.subtle.exportKey("jwk",e),{ext:t,key_ops:r,alg:n,use:a}=s;return ee(s,["ext","key_ops","alg","use"])})}function Ne(e){return u(this,null,function*(){return Ue(e)})}const le=(e,t)=>{const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:parseInt(e.slice(-3),10)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case"Ed25519":case"EdDSA":return{name:"Ed25519"};default:throw new w(`alg ${e} is not supported either by JOSE or your javascript runtime`)}},Se=(e,t,r)=>u(void 0,null,function*(){if(t instanceof Uint8Array){if(!e.startsWith("HS"))throw new TypeError(Y(t,"CryptoKey","KeyObject","JSON Web Key"));return crypto.subtle.importKey("raw",t,{hash:`SHA-${e.slice(-3)}`,name:"HMAC"},!1,[r])}return ge(t,e,r),t}),Be=(e,t,r,n)=>u(void 0,null,function*(){const a=yield Se(e,t,"verify");de(e,a);const o=le(e,a.algorithm);try{return yield crypto.subtle.verify(o,a,r,n)}catch(s){return!1}});function Le(e,t,r){return u(this,null,function*(){var Z;if(!G(e))throw new f("Flattened JWS must be an object");if(e.protected===void 0&&e.header===void 0)throw new f('Flattened JWS must have either of the "protected" or "header" members');if(e.protected!==void 0&&typeof e.protected!="string")throw new f("JWS Protected Header incorrect type");if(e.payload===void 0)throw new f("JWS Payload missing");if(typeof e.signature!="string")throw new f("JWS Signature missing or incorrect type");if(e.header!==void 0&&!G(e.header))throw new f("JWS Unprotected Header incorrect type");let n={};if(e.protected)try{const _=N(e.protected);n=JSON.parse(v.decode(_))}catch(_){throw new f("JWS Protected Header is invalid")}if(!fe(n,e.header))throw new f("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const a=m(m({},n),e.header),o=he(f,new Map([["b64",!0]]),r==null?void 0:r.crit,n,a);let s=!0;if(o.has("b64")&&(s=n.b64,typeof s!="boolean"))throw new f('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:i}=a;if(typeof i!="string"||!i)throw new f('JWS "alg" (Algorithm) Header Parameter missing or invalid');const c=r&&xe("algorithms",r.algorithms);if(c&&!c.has(i))throw new ae('"alg" (Algorithm) Header Parameter value not allowed');if(s){if(typeof e.payload!="string")throw new f("JWS Payload must be a string")}else if(typeof e.payload!="string"&&!(e.payload instanceof Uint8Array))throw new f("JWS Payload must be a string or an Uint8Array instance");let y=!1;typeof t=="function"&&(t=yield t(n,e),y=!0),ye(i,t,"verify");const A=ne(S.encode((Z=e.protected)!=null?Z:""),S.encode("."),typeof e.payload=="string"?S.encode(e.payload):e.payload);let J;try{J=N(e.signature)}catch(_){throw new f("Failed to base64url decode the signature")}const K=yield pe(t,i);if(!(yield Be(i,K,J,A)))throw new se;let D;if(s)try{D=N(e.payload)}catch(_){throw new f("Failed to base64url decode the payload")}else typeof e.payload=="string"?D=S.encode(e.payload):D=e.payload;const I={payload:D};return e.protected!==void 0&&(I.protectedHeader=n),e.header!==void 0&&(I.unprotectedHeader=e.header),y?U(m({},I),{key:K}):I})}function qe(e,t,r){return u(this,null,function*(){if(e instanceof Uint8Array&&(e=v.decode(e)),typeof e!="string")throw new f("Compact JWS must be a string or Uint8Array");const{0:n,1:a,2:o,length:s}=e.split(".");if(s!==3)throw new f("Invalid Compact JWS");const i=yield Le({payload:a,protected:n,signature:o},t,r),c={payload:i.payload,protectedHeader:i.protectedHeader};return typeof t=="function"?U(m({},c),{key:i.key}):c})}const Me=(e,t,r)=>u(void 0,null,function*(){const n=yield Se(e,t,"sign");de(e,n);const a=yield crypto.subtle.sign(le(e,n.algorithm),n,r);return new Uint8Array(a)});var O,p,l;class Ge{constructor(t){W(this,O);W(this,p);W(this,l);if(!(t instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");T(this,O,t)}setProtectedHeader(t){if(d(this,p))throw new TypeError("setProtectedHeader can only be called once");return T(this,p,t),this}setUnprotectedHeader(t){if(d(this,l))throw new TypeError("setUnprotectedHeader can only be called once");return T(this,l,t),this}sign(t,r){return u(this,null,function*(){if(!d(this,p)&&!d(this,l))throw new f("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!fe(d(this,p),d(this,l)))throw new f("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const n=m(m({},d(this,p)),d(this,l)),a=he(f,new Map([["b64",!0]]),r==null?void 0:r.crit,d(this,p),n);let o=!0;if(a.has("b64")&&(o=d(this,p).b64,typeof o!="boolean"))throw new f('The "b64" (base64url-encode payload) Header Parameter must be a boolean');const{alg:s}=n;if(typeof s!="string"||!s)throw new f('JWS "alg" (Algorithm) Header Parameter missing or invalid');ye(s,t,"sign");let i=d(this,O);o&&(i=S.encode(x(i)));let c;d(this,p)?c=S.encode(x(JSON.stringify(d(this,p)))):c=S.encode("");const y=ne(c,S.encode("."),i),A=yield pe(t,s),J=yield Me(s,A,y),K={signature:x(J),payload:""};return o&&(K.payload=v.decode(i)),d(this,l)&&(K.header=d(this,l)),d(this,p)&&(K.protected=v.decode(c)),K})}}O=new WeakMap,p=new WeakMap,l=new WeakMap;var C;class Xe{constructor(t){W(this,C);T(this,C,new Ge(t))}setProtectedHeader(t){return d(this,C).setProtectedHeader(t),this}sign(t,r){return u(this,null,function*(){const n=yield d(this,C).sign(t,r);if(n.payload===void 0)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${n.protected}.${n.payload}.${n.signature}`})}}C=new WeakMap;const b=(e,t)=>{if(typeof e!="string"||!e)throw new oe(`${t} missing or invalid`)};function Ze(e,t){return u(this,null,function*(){let r;if(B(e))r=e;else if(X(e))r=yield Ne(e);else throw new TypeError(Y(e,"CryptoKey","KeyObject","JSON Web Key"));if(t!=null||(t="sha256"),t!=="sha256"&&t!=="sha384"&&t!=="sha512")throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');let n;switch(r.kty){case"EC":b(r.crv,'"crv" (Curve) Parameter'),b(r.x,'"x" (X Coordinate) Parameter'),b(r.y,'"y" (Y Coordinate) Parameter'),n={crv:r.crv,kty:r.kty,x:r.x,y:r.y};break;case"OKP":b(r.crv,'"crv" (Subtype of Key Pair) Parameter'),b(r.x,'"x" (Public Key) Parameter'),n={crv:r.crv,kty:r.kty,x:r.x};break;case"RSA":b(r.e,'"e" (Exponent) Parameter'),b(r.n,'"n" (Modulus) Parameter'),n={e:r.e,kty:r.kty,n:r.n};break;case"oct":b(r.k,'"k" (Key Value) Parameter'),n={k:r.k,kty:r.kty};break;default:throw new w('"kty" (Key Type) Parameter missing or unsupported')}const a=S.encode(JSON.stringify(n));return x(yield Ce(t,a))})}export{Xe as CompactSign,Ge as FlattenedSign,Ze as calculateJwkThumbprint,qe as compactVerify,Ne as exportJWK,Le as flattenedVerify,ze as importPKCS8,Ye as importSPKI};
